{"name":"Util","tagline":"The util project, packed with common goodies.","body":"# util[![Build Status](https://travis-ci.org/websudos/util.svg?branch=develop)](https://travis-ci.org/websudos/util) [![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.websudos/util_2.10/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.websudos/util_2.10)\r\n\r\nThe latest available version of the util library is ```val UtilVersion = 0.7.5```. This library is only deployed to our managed Maven repository,\r\navailable at ```http://maven.websudos.co.uk```. It is publicly available, for both Scala 2.10.x and Scala 2.11.x.\r\n\r\n![Util](https://s3-eu-west-1.amazonaws.com/websudos/oss/logos/util.png \"Websudos Util\")\r\n \r\n### Table of contents ###\r\n\r\n<ol>\r\n  <li><a href=\"#integrating-the-util-library\">Integrating the util library</a></li>\r\n  \r\n  <li>\r\n    <p><a href=\"#util-http\">util-http</a></p>\r\n    <ul>\r\n      <li><a href=\"#option-parsers\">Option parsers</a></li>\r\n      <li><a href=\"#applicative-parsers\">Applicative parsers</a></li>\r\n    </ul>\r\n  </li>\r\n  \r\n    <li>\r\n      <p><a href=\"#util-parsers\">util-parsers</a></p>\r\n      <ul>\r\n        <li><a href=\"#option-parsers\">Option parsers</a></li>\r\n        <li><a href=\"#applicative-parsers\">Applicative parsers</a></li>\r\n      </ul>\r\n    </li>\r\n    \r\n  <li>\r\n    <p><a href=\"#util-testing\">util-testing</a></p>\r\n    <ul>\r\n      <li><a href=\"#async-assertions\">Async assertions</a></li>\r\n      <li><a href=\"#data-sampling\">Data sampling</a></li>\r\n    </ul>\r\n  </li>\r\n\r\n  <li>\r\n    <p><a href=\"#util-zookeeper\">util-zookeeper</a></p>\r\n    <ul>\r\n        <li><a href=\"#zookeeperinstance\">ZooKeeperInstance</a></li>\r\n        <li><a href=\"#zookeeperconf>ZooKeeperConf</a></li>\r\n    </ul>\r\n  </li>\r\n  \r\n  <li><a href=\"#contributors\">Copyright</a></li>\r\n  <li><a href=\"#style-guidelines\">Scala Style Guidelines</a></li>\r\n  <li><a href=\"#git-flow\">Git Flow</a></li>\r\n  <li><a href=\"#contributing\">Contributing</a></li>\r\n  <li><a href=\"#copyright\">Copyright</a></li>\r\n</ol>\r\n\r\n\r\n### Integrating the util library ###\r\n<a href=\"#table-of-contents\">Back to top</a>\r\n\r\n\r\nThe util library is designed to wrap common functionality in all our frameworks and offer it at the convenience of a dependency. Anything that will be useful\r\n long term to a great number of people belongs in these modules, to avoid duplication and help make our devs aware they can simply use what already exists.\r\n\r\nThe full list of available modules is:\r\n\r\n```scala\r\n\r\nlibraryDependencies ++= Seq(\r\n  \"com.websudos\" %% \"util-aws\" % UtilVersion,\r\n  \"com.websudos\" %% \"util-core\" % UtilVersion,\r\n  \"com.websudos\" %% \"util-http\" % UtilVersion,\r\n  \"com.websudos\" %% \"util-lift\" % UtilVersion,\r\n  \"com.websudos\" %% \"util-parsers\" % UtilVersion,\r\n  \"com.websudos\" %% \"util-testing\" % UtilVersion,\r\n  \"com.websudos\" %% \"util-zookeeper\" % UtilVersion\r\n)\r\n```\r\n\r\n\r\n### util-testing ###\r\n<a href=\"#table-of-contents\">Back to top</a>\r\n\r\nThe testing module features the ```AsyncAssertionsHelper```, which builds on top of ScalaTest to offer simple asynchronous assertions. We use this pattern \r\nheavily throughout the Websudos ecosystem of projects, from internal to DSL modules and so forth. Asynchronous testing generally offers a considerable \r\nperformance gain in code.\r\n\r\n\r\n### Async assertions ###\r\n<a href=\"#table-of-contents\">Back to top</a>\r\n\r\n\r\nThe async assertions module features a dual API, so you can call the same methods on both ```scala.concurrent.Future``` and ```com.twitter.util.Future```. \r\nThe underlying mechanism will create an async ```Waiter```, that will wait for the future to complete within the given ```PatienceConfiguration```. The \r\nawaiting is done asynchronously and the assertions are invoked and evaluated once the future in question has returned a result.\r\n\r\n```scala\r\nimport com.websudos.util.testing._\r\n\r\nclass MyTests extends FlatSuite with Matchers {\r\n\r\n  \"The async computation\" should \"return 0 on completion\" in {\r\n    val f: Future[Int] = .. // Pretend this is a Future just like any other future.\r\n    f.successful {\r\n      res => {\r\n        res shouldEqual 0\r\n      }\r\n    }\r\n  }\r\n  \r\n  \"This async computation\" should \"fail by design\" in {\r\n    val f: Future[Unit] = ..\r\n    \r\n    // You don't even need to do anything more than failure at this stage.\r\n    // If the Future fails, the test will succeed, as this method is used when you \"expect a failure\".\r\n    // You can however perform assertions on the error returned.\r\n    f.failing {\r\n      err => {\r\n      }\r\n    }\r\n  }\r\n  \r\n  \"This async computation\" should \"fail with a specific error\" in {\r\n      val f: Future[Unit] = ..\r\n      f.failingWith[NumberFormatException] {\r\n        err => {\r\n        }\r\n      }\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\nYou can directly customise the ```timeout``` of all ```Waiters``` using the ScalaTest specific time span implementations and interval configurations.\r\n\r\n\r\n```scala\r\nimport org.scalatest.concurrent.PatienceConfiguration\r\nimport org.scalatest.time.SpanSugar._\r\n\r\nimplicit val timeout: PatienceConfiguration.Timeout = timeout(20 seconds)\r\n\r\n```\r\n\r\nSummary:\r\n\r\n- The dependency you need is ```\"com.websudos\" %% \"util-testing\" % UtilVersion```.\r\n- You have to import ```com.websudos.util.testing._```.\r\n- You have three main assertion methods, ```successful```, ```failing```, and ```failingWith```.\r\n- You can configure the timeout of waiters with ```implicit val timeout: PatienceConfiguration.Timeout = timeout(20 seconds)```.\r\n- The default timeout value is ```1 second```.\r\n\r\n\r\n### Data sampling ###\r\n<a href=\"#table-of-contents\">Back to top</a>\r\n\r\nThis is a very common pattern we use in our testing and it's very easy to interchange this generation with something like ScalaCheck. The idea is very simple, you use type classes to define ways to sample a given type.\r\nAfter you define such a one-time sampling type class instance, you have access to several methods that will allow you to generate test data.\r\n\r\nIt's useful to define such typeclass instances inside package objects, as they will be \"invisibly\" imported in to the scope you need them to. This is often really neat, albeit potentially confusing for novice Scala users.\r\n\r\n\r\n```scala\r\n\r\nimport com.websudos.util.testing._\r\n\r\n\r\ncase class MyAwesomeClass(nane: String, age: Int, email: String)\r\n\r\npackage object mytest {\r\n\r\n  implicit object MyAwesomeClassSampler extends Sample[MyAwesomeClass] {\r\n    def sample: MyAwesomeClass = {\r\n      MyAwesomeClass(\r\n        gen[String],\r\n        gen[Int],\r\n        gen[EmailAddress].address\r\n      )\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nYou may notice this pattern is already available in better libraries such as ScalaMock and we are not trying to provide an alternative to ScalaMock or compete with it in any way. Our typeclass generator approach only becomes very useful where you really care about very specific properties of the data.\r\nFor instance, you may want to get a user with a valid email address, or you may use the underyling factories to get a name that ressembles the name of a real person, and so on.\r\n\r\nIt's also useful when you want to define specific ways in which hierarchies of classes are composed together into a sample. If generation for the sake of generation is all you care about, then ScalaMock with it's macro based approach is a far superior product simply because there's no typing effort involved.\r\n\r\nThere are multiple methods available, allowing you to generate more than just the type:\r\n \r\n- ```gen[T]```, used to generate a single instance of T.\r\n- ```gen[X, Y]```, used to generate a tuple based on two samples.\r\n- ```genOpt[T]```, convenience method that will give you back a ```Some[T](..)```.\r\n- ```genList[T](limit)```, convenience method that will give you back a ```List[T]```. The numbers of items in the list is equal to the ```limit``` and has a default value of 5 if not specified.\r\n- ```genMap[T]()```, convenience method that will give you back a ```Map[String, T]```.\r\n\r\n\r\nThere is also a default list of available generators for some default types. For things like ```EmailAddress```, the point of the extra class is obviously to distinguish the type during implicit resolution, but you don't need to use our abstraction at all, there will always be an easy way to get to the underlying generated primitives.\r\n\r\nIn the case of email addresses, you can use ```gen[EmailAddress].address```, which will correctly generate a valid ```EmailAddress``` but you can work directly with a ```String```.\r\n\r\n- ```scala.Int```\r\n- ```scala.Double```\r\n- ```scala.Float```\r\n- ```scala.Long```\r\n- ```scala.String```\r\n- ```scala.math.BigDecimal```\r\n- ```scala.math.BigInt```\r\n- ```java.util.Date```\r\n- ```java.util.UUID```\r\n- ```org.joda.time.DateTime```\r\n- ```org.joda.time.LocalDate```\r\n- ```com.websudos.util.testing.EmailAddress(address)```\r\n\r\n\r\n### util-parsers ###\r\n<a href=\"#table-of-contents\">Back to top</a>\r\n\r\nThe parser module features an easy to use and integrate set of ScalaZ Applicative based parsers, with an ```Option``` based parser variant. It allows us to \r\nseamlessly deal with validation chains at REST API level or whenever validation is involved. Whether it's monadic composition of options or chaining of \r\napplicative functors to obtain a \"correct\" chain, the parser module is designed to offer an all-you-can-eat buffet of mini parsers that can be easily \r\ncomposed to suit any validation needs. \r\n\r\nEach parser comes in three distinct flavours, a ```ValidationNel``` parser that parsers the end type from a ```String``` and returns the type itself, \r\na parser that parses an end result from an ```Option[String]``` and parserOpt variant that returns an ```Option[T]``` instead of a ```ValidationNel[String, \r\nT]```, which allows for Monadic composition, where you need to \"short-circuit\" evaluation and validation, instead of computing the full chain by chaining \r\napplicatives.\r\n\r\nTo illustrate the above, the ```int``` parser, designed to parse a ```scala.Int``` value from a ```String```, packages the following three signatures:\r\n\r\n```scala\r\n  final def intOpt(str: String)\r\n\r\n  final def int(str: String): ValidationNel[String, Int]\r\n\r\n  final def int(str: Option[String]): ValidationNel[String, Int]\r\n```\r\n\r\n\r\n### Option parsers ###\r\n<a href=\"#table-of-contents\">Back to top</a>\r\n\r\nThe full list of optional parsers is:\r\n\r\n\r\n| Name            | Input type                | Output type                       |\r\n| --------------- |---------------------------| --------------------------------- |\r\n| intOpt          | String\\|Option[String]     | Option[Int]                       |\r\n| longOpt         | String\\|Option[String]     | Option[Long]                      |\r\n| doubleOpt       | String\\|Option[String]     | Option[Double]                    |\r\n| floatOpt        | String\\|Option[String]     | Option[Float]                     |\r\n| uuidOpt         | String\\|Option[String]     | Option[java.util.UUID]            |\r\n| emailOpt        | String\\|Option[String]     | Option[String]                    |\r\n| timestampOpt    | String\\|Option[String]     | Option[org.joda.time.DateTime]    |\r\n| dateOpt         | String\\|Option[String]     | Option[org.joda.time.DateTime]    |\r\n\r\n\r\nOption parsers are designed for chains where you want to short-circuit and exit to result as soon a parser fails. This short-circuit behaviour is the default\r\n ```flatMap``` behaviour of an ```Option```, as soon as an ```Option``` is ```None``` the chain breaks. Unlike applicatives, \r\n the evaluation sequence of options will be escaped and you cannot for instance return an error for every parser that couldn't validate. Instead, \r\n you will only get the first error in the sequence.\r\n \r\nAn example of how to use ```Option``` parsers might be:\r\n\r\n```scala\r\n\r\nimport com.websudos.util.parsers._\r\n\r\nobject Test {\r\n  def optionalParsing(email: String, age: String): Unit = {\r\n    for {\r\n      validEmail <- emailOpt(email)\r\n      validAge <- intOpt(age)\r\n    } yield s\"This person can be reached at $validEmail and is $validAge years old\"\r\n  }\r\n}\r\n\r\n```\r\n\r\n\r\n### Applicative parsers ###\r\n<a href=\"#table-of-contents\">Back to top</a>\r\n\r\nThe full list of ScalaZ Validation based applicative parsers is:\r\n\r\n| Name            | Input type                | Parser Output type                |\r\n| --------------- |---------------------------| --------------------------------- |\r\n| int             | String\\|Option[String]     | ValidationNel[String, Int]        |\r\n| long            | String\\|Option[String]     | ValidationNel[String, Long]       |\r\n| double          | String\\|Option[String]     | ValidationNel[String, Double]     |\r\n| float           | String\\|Option[String]     | ValidationNel[String, Float]      |\r\n| uuid            | String\\|Option[String]     | ValidationNel[String, UUID]       |\r\n| email           | String\\|Option[String]     | ValidationNel[String, String]     |\r\n| timestamp       | String\\|Option[String]     | ValidationNel[String, org.joda.time.DateTime]   |\r\n| date            | String\\|Option[String]     | ValidationNel[String, org.joda.time.DateTime]   |\r\n\r\nTo illustrate the basic usage of applicative parsers and how to chain them, have a look below.\r\n\r\n```scala\r\n\r\nimport scalaz._\r\nimport scalaz.Scalaz._\r\nimport com.websudos.util.parsers._\r\n\r\nobject Test {\r\n  \r\n  def registerUser(str: String, age: String): Unit = {\r\n    (email(str) |@| int(age)) {\r\n      (validEmail, validAge) => {\r\n      }\r\n    }.fold {\r\n      // .. \r\n    }\r\n  }\r\n  \r\n}\r\n```\r\n\r\n### util-zookeeper ###\r\n\r\nThe ZooKeeper utilities are a set of convenience utilities for using ZooKeeper as a service discovery tool in your eco-system. The tooling found in this project is relatively small and most of the underlying functionality has already been very well address by Twitter and by the finagle-zookeeper project.\r\n\r\n\r\n### ZooKeeperInstance ###\r\n\r\nThis is useful when you want to test against a local ZooKeeper installation but you don't really want to provision ZooKeeper in your test environment. It's a really neat trick to pull when you want to test your distribution across a service discovery based eco-system.\r\n\r\nThe instance is meant to allow testing on a specific path and it will automatically provision the path you pass as an argument to it. However, you can exactly create further paths using the client.\r\n\r\n```scala\r\nval instance = new ZooKeeperInstance(path)\r\n\r\n// Now you have 2 control methods.\r\ninstance.start()\r\n\r\n// And you can stop the instance and free up the port\r\ninstance.stop()\r\n```\r\n\r\n### ZooKeeperConf ###\r\n\r\nThis is indented for applications that want to register themselves to ZooKeeper nodes or fetch a set of ```host:port``` combinations from ZooKeeper. The underlying Scala collection we use for this config is a ```Set```, which means no duplicates are allowed by design.\r\nInternally, we heavily use the Twitter eco-system for development and we use Finagle + Twitter Server to create applications that are later discovered by other apps via ZooKeeper. As such, we provide a sequence of asynchronous/reactive access patterns to allow our apps to quickly access ZooKeeper.\r\n\r\n\r\n\r\n### Contributors\r\n<a href=\"#table-of-contents\">Back to top</a>\r\n\r\n- Flavian Alexandru @alexflav23\r\n- Jens Halm @jenshalm\r\n- Bartosz Jankiewicz @bjankie1\r\n\r\n\r\n<a id=\"copyright\">Copyright</a>\r\n===============================\r\n<a href=\"#table-of-contents\">Back to top</a>\r\n\r\nCopyright (c) 2014 websudos.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}